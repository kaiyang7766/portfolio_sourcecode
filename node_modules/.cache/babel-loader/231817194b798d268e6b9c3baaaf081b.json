{"ast":null,"code":"import Level from '../Level.js';\nimport { createBackgroundLayer, createSpriteLayer } from '../layers.js';\nimport { loadJSON, loadSpriteSheet } from '../loaders.js';\nimport { Matrix } from '../math.js';\nexport function loadLevel(name) {\n  return loadJSON(`./levels/${name}.json`).then(levelSpec => Promise.all([levelSpec, loadSpriteSheet(levelSpec.spriteSheet)])).then(([levelSpec, sprites]) => {\n    const level = new Level();\n    const mergedTiles = levelSpec.layers.reduce((mergedTiles, layerSpec) => {\n      return mergedTiles.concat(layerSpec.tiles);\n    }, []);\n    const collisionGrid = createCollisionGrid(mergedTiles, levelSpec.patterns);\n    level.setCollisionGrid(collisionGrid);\n    levelSpec.layers.forEach(layer => {\n      const backgroundGrid = createBackgroundGrid(layer.tiles, levelSpec.patterns);\n      const backgroundLayer = createBackgroundLayer(level, backgroundGrid, sprites);\n      level.comp.layers.push(backgroundLayer);\n    });\n    const spriteLayer = createSpriteLayer(level.entities);\n    level.comp.layers.push(spriteLayer);\n    return level;\n  });\n}\n\nfunction createCollisionGrid(tiles, patterns) {\n  const grid = new Matrix();\n\n  for (const {\n    tile,\n    x,\n    y\n  } of expandTiles(tiles, patterns)) {\n    grid.set(x, y, {\n      type: tile.type\n    });\n  }\n\n  return grid;\n}\n\nfunction createBackgroundGrid(tiles, patterns) {\n  const grid = new Matrix();\n\n  for (const {\n    tile,\n    x,\n    y\n  } of expandTiles(tiles, patterns)) {\n    grid.set(x, y, {\n      name: tile.name\n    });\n  }\n\n  return grid;\n}\n\nfunction* expandSpan(xStart, xLen, yStart, yLen) {\n  const xEnd = xStart + xLen;\n  const yEnd = yStart + yLen;\n\n  for (let x = xStart; x < xEnd; ++x) {\n    for (let y = yStart; y < yEnd; ++y) {\n      yield {\n        x,\n        y\n      };\n    }\n  }\n}\n\nfunction expandRange(range) {\n  if (range.length === 4) {\n    const [xStart, xLen, yStart, yLen] = range;\n    return expandSpan(xStart, xLen, yStart, yLen);\n  } else if (range.length === 3) {\n    const [xStart, xLen, yStart] = range;\n    return expandSpan(xStart, xLen, yStart, 1);\n  } else if (range.length === 2) {\n    const [xStart, yStart] = range;\n    return expandSpan(xStart, 1, yStart, 1);\n  }\n}\n\nfunction* expandRanges(ranges) {\n  for (const range of ranges) {\n    for (const item of expandRange(range)) {\n      yield item;\n    }\n  }\n}\n\nfunction expandTiles(tiles, patterns) {\n  const expandedTiles = [];\n\n  function walkTiles(tiles, offsetX, offsetY) {\n    for (const tile of tiles) {\n      for (const {\n        x,\n        y\n      } of expandRanges(tile.ranges)) {\n        const derivedX = x + offsetX;\n        const derivedY = y + offsetY;\n\n        if (tile.pattern) {\n          const tiles = patterns[tile.pattern].tiles;\n          walkTiles(tiles, derivedX, derivedY);\n        } else {\n          expandedTiles.push({\n            tile,\n            x: derivedX,\n            y: derivedY\n          });\n        }\n      }\n    }\n  }\n\n  walkTiles(tiles, 0, 0);\n  return expandedTiles;\n}","map":{"version":3,"sources":["C:/Users/Ang Kai Yang/Desktop/portfolio1/src/js/loaders/level.js"],"names":["Level","createBackgroundLayer","createSpriteLayer","loadJSON","loadSpriteSheet","Matrix","loadLevel","name","then","levelSpec","Promise","all","spriteSheet","sprites","level","mergedTiles","layers","reduce","layerSpec","concat","tiles","collisionGrid","createCollisionGrid","patterns","setCollisionGrid","forEach","layer","backgroundGrid","createBackgroundGrid","backgroundLayer","comp","push","spriteLayer","entities","grid","tile","x","y","expandTiles","set","type","expandSpan","xStart","xLen","yStart","yLen","xEnd","yEnd","expandRange","range","length","expandRanges","ranges","item","expandedTiles","walkTiles","offsetX","offsetY","derivedX","derivedY","pattern"],"mappings":"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","sourcesContent":["import Level from '../Level.js';\r\nimport {createBackgroundLayer, createSpriteLayer} from '../layers.js';\r\nimport {loadJSON, loadSpriteSheet} from '../loaders.js';\r\nimport {Matrix} from '../math.js';\r\n\r\nexport function loadLevel(name){\r\n\treturn loadJSON(`./levels/${name}.json`)\r\n\t.then(levelSpec => Promise.all([\r\n\t\tlevelSpec,\r\n\t\tloadSpriteSheet(levelSpec.spriteSheet),\r\n\t]))\r\n\t.then(([levelSpec,sprites])=>{\r\n\t\tconst level = new Level();\r\n\r\n\t\tconst mergedTiles=levelSpec.layers.reduce((mergedTiles,layerSpec)=>{\r\n\t\t\treturn mergedTiles.concat(layerSpec.tiles);\r\n\t\t}, []);\r\n\t\tconst collisionGrid=createCollisionGrid(mergedTiles,levelSpec.patterns)\r\n\t\tlevel.setCollisionGrid(collisionGrid);\r\n\r\n\t\tlevelSpec.layers.forEach(layer=>{\r\n\t\tconst backgroundGrid=createBackgroundGrid(layer.tiles,levelSpec.patterns)\r\n \t\tconst backgroundLayer=createBackgroundLayer(level,backgroundGrid, sprites);\r\n \t\tlevel.comp.layers.push(backgroundLayer);\r\n \t\t});\r\n\r\n \t\tconst spriteLayer=createSpriteLayer(level.entities);\r\n \t\tlevel.comp.layers.push(spriteLayer);\r\n\r\n \t\treturn level;\r\n\t})\r\n}\r\n\r\nfunction createCollisionGrid(tiles,patterns){\r\n\tconst grid=new Matrix();\r\n\r\n\tfor (const {tile,x,y} of expandTiles(tiles,patterns)){\r\n\t\t\tgrid.set(x,y,{type:tile.type});\r\n\t\t}\r\n\r\n\t\treturn grid;\r\n}\r\n\r\nfunction createBackgroundGrid(tiles,patterns){\r\n\tconst grid=new Matrix();\r\n\r\n\tfor (const {tile,x,y} of expandTiles(tiles,patterns)){\r\n\t\t\tgrid.set(x,y,{name:tile.name});\r\n\t\t}\r\n\r\n\t\treturn grid;\r\n}\r\n\r\nfunction* expandSpan(xStart,xLen,yStart,yLen){\r\n\tconst xEnd=xStart+xLen;\r\n\tconst yEnd=yStart+yLen;\r\n\tfor (let x=xStart;x<xEnd;++x){\r\n\t\tfor (let y=yStart;y<yEnd;++y){\r\n\t\t\tyield {x,y};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction expandRange(range){\r\n\tif (range.length===4){\r\n\t\tconst [xStart,xLen,yStart,yLen]=range;\r\n\t\treturn expandSpan(xStart,xLen,yStart,yLen);\r\n\t}\r\n\r\n\telse if (range.length===3){\r\n\t\tconst [xStart,xLen,yStart]=range;\r\n\t\treturn expandSpan(xStart,xLen,yStart,1);\r\n\t}\r\n\r\n\telse if (range.length===2){\r\n\t\tconst [xStart,yStart]=range;\r\n\t\treturn expandSpan(xStart,1,yStart,1);\r\n\t}\r\n}\r\n\r\nfunction* expandRanges(ranges){\r\n\tfor (const range of ranges){\r\n\t\tfor (const item of expandRange(range)){\r\n\t\t\tyield item;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction expandTiles(tiles,patterns){\r\n\tconst expandedTiles =[];\r\n\r\n\tfunction walkTiles(tiles,offsetX,offsetY){\r\n\t\tfor (const tile of tiles){\r\n\t\t\tfor (const {x,y} of expandRanges(tile.ranges)){\r\n\t\t\t\tconst derivedX=x+offsetX;\r\n\t\t\t\tconst derivedY=y+offsetY;\r\n\r\n\t\t\t\tif (tile.pattern){\r\n\t\t\t\t\t\tconst tiles=patterns[tile.pattern].tiles;\r\n\t\t\t\t\t\twalkTiles(tiles,derivedX,derivedY);\r\n\t\t\t\t\t} else{\r\n\t\t\t\t\t\texpandedTiles.push({\r\n\t\t\t\t\t\t\ttile,\r\n\t\t\t\t\t\t\tx:derivedX,\r\n\t\t\t\t\t\t\ty:derivedY,\r\n\t\t\t\t\t\t}); \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\twalkTiles(tiles,0,0);\r\n\r\n\treturn expandedTiles;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}