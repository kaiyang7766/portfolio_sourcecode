{"ast":null,"code":"import TileResolver from './TileResolver.js';\nimport Camera from './Camera.js';\nexport function createBackgroundLayer(level, tiles, sprites) {\n  const resolver = new TileResolver(tiles);\n  const camera = new Camera();\n  const buffer = document.createElement('canvas');\n  buffer.width = 550;\n  buffer.height = 640;\n  const context = buffer.getContext('2d');\n\n  function redraw(startIndex, endIndex) {\n    context.clearRect(0, 0, buffer.width, buffer.height);\n\n    for (let x = startIndex; x <= endIndex; ++x) {\n      const col = tiles.grid[x];\n\n      if (col) {\n        col.forEach((tile, y) => {\n          if (sprites.animation.has(tile.name)) {\n            sprites.drawAnim(tile.name, context, x - startIndex, y, level.totalTime);\n          } else {\n            sprites.drawtile(tile.name, context, x - startIndex, y);\n          }\n        });\n      }\n    }\n  }\n\n  return function drawBackgroundLayer(context, camera) {\n    const drawWidth = resolver.toIndex(camera.size.x);\n    const drawFrom = resolver.toIndex(camera.pos.x);\n    const drawTo = drawFrom + drawWidth;\n    redraw(drawFrom, drawTo); //+screenwidth here\n\n    context.drawImage(buffer, -camera.pos.x % 16, -camera.pos.y);\n  };\n}\nexport function createSpriteLayer(entities, width = 64, height = 64) {\n  const spriteBuffer = document.createElement('canvas');\n  spriteBuffer.width = width;\n  spriteBuffer.height = height;\n  const spriteBufferContext = spriteBuffer.getContext('2d');\n  return function drawSpriteLayer(context) {\n    entities.forEach(entity => {\n      spriteBufferContext.clearRect(0, 0, width, height);\n      entity.draw(spriteBufferContext);\n      context.drawImage(spriteBuffer, entity.pos.x - camera.pos.x, entity.pos.y - camera.pos.y);\n    });\n  };\n}\nexport function createCollisionLayer(level) {\n  const resolvedTiles = [];\n  const tileResolver = level.tileCollider.tiles;\n  const tileSize = tileResolver.tileSize;\n  const getByIndexOriginal = tileResolver.getByIndex;\n\n  tileResolver.getByIndex = function getByIndexFake(x, y) {\n    resolvedTiles.push({\n      x,\n      y\n    });\n    return getByIndexOriginal.call(tileResolver, x, y);\n  };\n\n  return function drawCollision(context) {\n    context.strokeStyle = 'blue';\n    resolvedTiles.forEach(({\n      x,\n      y\n    }) => {\n      context.beginPath();\n      context.rect(x * tileSize - camera.pos.x, y * tileSize - camera.pos.y, tileSize, tileSize); //context.stroke();\n      //console.log('Would draw',x,y);\n    });\n    context.strokeStyle = 'red';\n    level.entities.forEach(entity => {\n      context.beginPath();\n      context.rect(entity.pos.x - camera.pos.x, entity.pos.y - camera.pos.y, entity.size.x, entity.size.y); //context.stroke();\n    });\n    resolvedTiles.length = 0;\n  };\n}\nexport function createCameraLayer(cameraToDraw) {\n  return function drawCameraRect(context, fromCamera) {\n    context.strokeStyle = 'purple';\n    context.beginPath();\n    context.rect(cameraToDraw.pos.x - fromCamera.pos.x, cameraToDraw.pos.y - fromCamera.pos.y, cameraToDraw.size.x, cameraToDraw.size.y);\n    context.stroke();\n  };\n}","map":{"version":3,"sources":["C:/Users/Ang Kai Yang/Desktop/portfolio/src/main/layers.js"],"names":["TileResolver","Camera","createBackgroundLayer","level","tiles","sprites","resolver","camera","buffer","document","createElement","width","height","context","getContext","redraw","startIndex","endIndex","clearRect","x","col","grid","forEach","tile","y","animation","has","name","drawAnim","totalTime","drawtile","drawBackgroundLayer","drawWidth","toIndex","size","drawFrom","pos","drawTo","drawImage","createSpriteLayer","entities","spriteBuffer","spriteBufferContext","drawSpriteLayer","entity","draw","createCollisionLayer","resolvedTiles","tileResolver","tileCollider","tileSize","getByIndexOriginal","getByIndex","getByIndexFake","push","call","drawCollision","strokeStyle","beginPath","rect","length","createCameraLayer","cameraToDraw","drawCameraRect","fromCamera","stroke"],"mappings":"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","sourcesContent":["import TileResolver from './TileResolver.js';\r\nimport Camera from './Camera.js';\r\n\r\nexport function createBackgroundLayer (level,tiles, sprites){\r\n\tconst resolver = new TileResolver(tiles);\r\n\tconst camera=new Camera();\r\n\r\n\tconst buffer=document.createElement('canvas');\r\n \tbuffer.width=550;\r\n \tbuffer.height=640;\r\n \tconst context=buffer.getContext('2d');\r\n\r\n \tfunction redraw(startIndex,endIndex){\r\n \t\tcontext.clearRect(0,0,buffer.width,buffer.height);\r\n \t\tfor (let x=startIndex;x<=endIndex;++x){\r\n \t\t\tconst col = tiles.grid[x];\r\n \t\t\tif (col){\r\n \t\t\t\tcol.forEach((tile,y)=>{\r\n \t\t\t\t\tif (sprites.animation.has(tile.name)){\r\n \t\t\t\t\t\tsprites.drawAnim(tile.name,context,x-startIndex,y,level.totalTime);\r\n \t\t\t\t\t} else {\r\n \t\t\t\t\t\tsprites.drawtile(tile.name,context,x-startIndex,y);\r\n \t\t\t\t\t}\r\n \t\t\t\t});\r\n \t\t\t}\r\n \t\t}\r\n \t}\r\n\r\n \treturn function drawBackgroundLayer(context,camera){\r\n \t\tconst drawWidth=resolver.toIndex(camera.size.x);\r\n \t\tconst drawFrom=resolver.toIndex(camera.pos.x);\r\n \t\tconst drawTo=drawFrom+drawWidth;\r\n \t\tredraw(drawFrom,drawTo);  //+screenwidth here\r\n \t\tcontext.drawImage(buffer,\r\n \t\t\t-camera.pos.x%16,\r\n \t\t\t-camera.pos.y);\r\n \t};\r\n}\r\n\r\nexport function createSpriteLayer(entities, width=64,height=64){\r\n\tconst spriteBuffer=document.createElement('canvas');\r\n\tspriteBuffer.width=width;\r\n\tspriteBuffer.height=height;\r\n\tconst spriteBufferContext=spriteBuffer.getContext('2d');\r\n\r\n\treturn function drawSpriteLayer(context){\r\n\t\tentities.forEach(entity=>{\r\n\t\t\tspriteBufferContext.clearRect(0,0,width,height);\r\n\r\n\t\t\tentity.draw(spriteBufferContext);\r\n\r\n\t\t\tcontext.drawImage(\r\n\t\t\t\tspriteBuffer,\r\n\t\t\t\tentity.pos.x-camera.pos.x,\r\n\t\t\t\tentity.pos.y-camera.pos.y);\r\n\t\t});\r\n\t};\r\n}\r\n\r\nexport function createCollisionLayer(level){\r\n\tconst resolvedTiles=[];\r\n\r\n\tconst tileResolver=level.tileCollider.tiles;\r\n\tconst tileSize=tileResolver.tileSize;\r\n\r\n\tconst getByIndexOriginal=tileResolver.getByIndex;\r\n\ttileResolver.getByIndex=function getByIndexFake(x,y){\r\n\t\tresolvedTiles.push({x,y});\r\n\t\treturn getByIndexOriginal.call(tileResolver,x,y);\r\n\t}\r\n\r\n\treturn function drawCollision(context){\r\n\t\tcontext.strokeStyle='blue';\r\n\t\tresolvedTiles.forEach(({x,y})=>{\r\n\t\t\tcontext.beginPath();\r\n\t\t\tcontext.rect(\r\n\t\t\t\tx*tileSize-camera.pos.x,\r\n\t\t\t\ty*tileSize-camera.pos.y,\r\n\t\t\t\ttileSize,tileSize);\r\n\t\t\t//context.stroke();\r\n\t\t\t//console.log('Would draw',x,y);\r\n\t\t});\r\n\r\n\t\tcontext.strokeStyle='red';\r\n\t\tlevel.entities.forEach(entity=>{\r\n\t\t\tcontext.beginPath();\r\n\t\t\tcontext.rect(\r\n\t\t\t\tentity.pos.x-camera.pos.x,\r\n\t\t\t\tentity.pos.y-camera.pos.y,\r\n\t\t\t\tentity.size.x,\r\n\t\t\t\tentity.size.y);\r\n\t\t\t//context.stroke();\r\n\t\t})\r\n\r\n\t\tresolvedTiles.length=0;\r\n\t};\r\n}\r\n\r\nexport function createCameraLayer(cameraToDraw){\r\n\treturn function drawCameraRect(context,fromCamera){\r\n\t\tcontext.strokeStyle='purple';\r\n\t\tcontext.beginPath();\r\n\t\t\tcontext.rect(\r\n\t\t\t\tcameraToDraw.pos.x-fromCamera.pos.x,\r\n\t\t\t\tcameraToDraw.pos.y-fromCamera.pos.y,\r\n\t\t\t\tcameraToDraw.size.x,\r\n\t\t\t\tcameraToDraw.size.y);\r\n\t\t\tcontext.stroke();\r\n\t};\r\n}"]},"metadata":{},"sourceType":"module"}