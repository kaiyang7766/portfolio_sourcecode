{"ast":null,"code":"import TileResolver from './TileResolver.js';\nexport function createBackgroundLayer(level, tiles, sprites) {\n  const resolver = new TileResolver(tiles); //const buffer=document.createElement('canvas');\n\n  buffer.width = 550;\n  buffer.height = 640;\n  const context = buffer.getContext('2d');\n\n  function redraw(startIndex, endIndex) {\n    context.clearRect(0, 0, buffer.width, buffer.height);\n\n    for (let x = startIndex; x <= endIndex; ++x) {\n      const col = tiles.grid[x];\n\n      if (col) {\n        col.forEach((tile, y) => {\n          if (sprites.animation.has(tile.name)) {\n            sprites.drawAnim(tile.name, context, x - startIndex, y, level.totalTime);\n          } else {\n            sprites.drawtile(tile.name, context, x - startIndex, y);\n          }\n        });\n      }\n    }\n  }\n\n  return function drawBackgroundLayer(context, camera) {\n    const drawWidth = resolver.toIndex(camera.size.x);\n    const drawFrom = resolver.toIndex(camera.pos.x);\n    const drawTo = drawFrom + drawWidth;\n    redraw(drawFrom, drawTo); //+screenwidth here\n\n    context.drawImage(buffer, -camera.pos.x % 16, -camera.pos.y);\n  };\n}\nexport function createSpriteLayer(entities, width = 64, height = 64) {\n  const spriteBuffer = document.createElement('canvas');\n  spriteBuffer.width = width;\n  spriteBuffer.height = height;\n  const spriteBufferContext = spriteBuffer.getContext('2d');\n  return function drawSpriteLayer(context) {\n    entities.forEach(entity => {\n      spriteBufferContext.clearRect(0, 0, width, height);\n      entity.draw(spriteBufferContext);\n      context.drawImage(spriteBuffer, entity.pos.x - camera.pos.x, entity.pos.y - camera.pos.y);\n    });\n  };\n}\nexport function createCollisionLayer(level) {\n  const resolvedTiles = [];\n  const tileResolver = level.tileCollider.tiles;\n  const tileSize = tileResolver.tileSize;\n  const getByIndexOriginal = tileResolver.getByIndex;\n\n  tileResolver.getByIndex = function getByIndexFake(x, y) {\n    resolvedTiles.push({\n      x,\n      y\n    });\n    return getByIndexOriginal.call(tileResolver, x, y);\n  };\n\n  return function drawCollision(context) {\n    context.strokeStyle = 'blue';\n    resolvedTiles.forEach(({\n      x,\n      y\n    }) => {\n      context.beginPath();\n      context.rect(x * tileSize - camera.pos.x, y * tileSize - camera.pos.y, tileSize, tileSize); //context.stroke();\n      //console.log('Would draw',x,y);\n    });\n    context.strokeStyle = 'red';\n    level.entities.forEach(entity => {\n      context.beginPath();\n      context.rect(entity.pos.x - camera.pos.x, entity.pos.y - camera.pos.y, entity.size.x, entity.size.y); //context.stroke();\n    });\n    resolvedTiles.length = 0;\n  };\n}\nexport function createCameraLayer(cameraToDraw) {\n  return function drawCameraRect(context, fromCamera) {\n    context.strokeStyle = 'purple';\n    context.beginPath();\n    context.rect(cameraToDraw.pos.x - fromCamera.pos.x, cameraToDraw.pos.y - fromCamera.pos.y, cameraToDraw.size.x, cameraToDraw.size.y);\n    context.stroke();\n  };\n}","map":{"version":3,"sources":["C:/Users/Ang Kai Yang/Desktop/portfolio/src/main/layers.js"],"names":["TileResolver","createBackgroundLayer","level","tiles","sprites","resolver","buffer","width","height","context","getContext","redraw","startIndex","endIndex","clearRect","x","col","grid","forEach","tile","y","animation","has","name","drawAnim","totalTime","drawtile","drawBackgroundLayer","camera","drawWidth","toIndex","size","drawFrom","pos","drawTo","drawImage","createSpriteLayer","entities","spriteBuffer","document","createElement","spriteBufferContext","drawSpriteLayer","entity","draw","createCollisionLayer","resolvedTiles","tileResolver","tileCollider","tileSize","getByIndexOriginal","getByIndex","getByIndexFake","push","call","drawCollision","strokeStyle","beginPath","rect","length","createCameraLayer","cameraToDraw","drawCameraRect","fromCamera","stroke"],"mappings":"AAAA,OAAOA,YAAP,MAAyB,mBAAzB;AAEA,OAAO,SAASC,qBAAT,CAAgCC,KAAhC,EAAsCC,KAAtC,EAA6CC,OAA7C,EAAqD;AAC3D,QAAMC,QAAQ,GAAG,IAAIL,YAAJ,CAAiBG,KAAjB,CAAjB,CAD2D,CAG3D;;AACCG,EAAAA,MAAM,CAACC,KAAP,GAAa,GAAb;AACAD,EAAAA,MAAM,CAACE,MAAP,GAAc,GAAd;AACA,QAAMC,OAAO,GAACH,MAAM,CAACI,UAAP,CAAkB,IAAlB,CAAd;;AAEA,WAASC,MAAT,CAAgBC,UAAhB,EAA2BC,QAA3B,EAAoC;AACnCJ,IAAAA,OAAO,CAACK,SAAR,CAAkB,CAAlB,EAAoB,CAApB,EAAsBR,MAAM,CAACC,KAA7B,EAAmCD,MAAM,CAACE,MAA1C;;AACA,SAAK,IAAIO,CAAC,GAACH,UAAX,EAAsBG,CAAC,IAAEF,QAAzB,EAAkC,EAAEE,CAApC,EAAsC;AACrC,YAAMC,GAAG,GAAGb,KAAK,CAACc,IAAN,CAAWF,CAAX,CAAZ;;AACA,UAAIC,GAAJ,EAAQ;AACPA,QAAAA,GAAG,CAACE,OAAJ,CAAY,CAACC,IAAD,EAAMC,CAAN,KAAU;AACrB,cAAIhB,OAAO,CAACiB,SAAR,CAAkBC,GAAlB,CAAsBH,IAAI,CAACI,IAA3B,CAAJ,EAAqC;AACpCnB,YAAAA,OAAO,CAACoB,QAAR,CAAiBL,IAAI,CAACI,IAAtB,EAA2Bd,OAA3B,EAAmCM,CAAC,GAACH,UAArC,EAAgDQ,CAAhD,EAAkDlB,KAAK,CAACuB,SAAxD;AACA,WAFD,MAEO;AACNrB,YAAAA,OAAO,CAACsB,QAAR,CAAiBP,IAAI,CAACI,IAAtB,EAA2Bd,OAA3B,EAAmCM,CAAC,GAACH,UAArC,EAAgDQ,CAAhD;AACA;AACD,SAND;AAOA;AACD;AACD;;AAED,SAAO,SAASO,mBAAT,CAA6BlB,OAA7B,EAAqCmB,MAArC,EAA4C;AAClD,UAAMC,SAAS,GAACxB,QAAQ,CAACyB,OAAT,CAAiBF,MAAM,CAACG,IAAP,CAAYhB,CAA7B,CAAhB;AACA,UAAMiB,QAAQ,GAAC3B,QAAQ,CAACyB,OAAT,CAAiBF,MAAM,CAACK,GAAP,CAAWlB,CAA5B,CAAf;AACA,UAAMmB,MAAM,GAACF,QAAQ,GAACH,SAAtB;AACAlB,IAAAA,MAAM,CAACqB,QAAD,EAAUE,MAAV,CAAN,CAJkD,CAIxB;;AAC1BzB,IAAAA,OAAO,CAAC0B,SAAR,CAAkB7B,MAAlB,EACC,CAACsB,MAAM,CAACK,GAAP,CAAWlB,CAAZ,GAAc,EADf,EAEC,CAACa,MAAM,CAACK,GAAP,CAAWb,CAFb;AAGA,GARD;AASD;AAED,OAAO,SAASgB,iBAAT,CAA2BC,QAA3B,EAAqC9B,KAAK,GAAC,EAA3C,EAA8CC,MAAM,GAAC,EAArD,EAAwD;AAC9D,QAAM8B,YAAY,GAACC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAnB;AACAF,EAAAA,YAAY,CAAC/B,KAAb,GAAmBA,KAAnB;AACA+B,EAAAA,YAAY,CAAC9B,MAAb,GAAoBA,MAApB;AACA,QAAMiC,mBAAmB,GAACH,YAAY,CAAC5B,UAAb,CAAwB,IAAxB,CAA1B;AAEA,SAAO,SAASgC,eAAT,CAAyBjC,OAAzB,EAAiC;AACvC4B,IAAAA,QAAQ,CAACnB,OAAT,CAAiByB,MAAM,IAAE;AACxBF,MAAAA,mBAAmB,CAAC3B,SAApB,CAA8B,CAA9B,EAAgC,CAAhC,EAAkCP,KAAlC,EAAwCC,MAAxC;AAEAmC,MAAAA,MAAM,CAACC,IAAP,CAAYH,mBAAZ;AAEAhC,MAAAA,OAAO,CAAC0B,SAAR,CACCG,YADD,EAECK,MAAM,CAACV,GAAP,CAAWlB,CAAX,GAAaa,MAAM,CAACK,GAAP,CAAWlB,CAFzB,EAGC4B,MAAM,CAACV,GAAP,CAAWb,CAAX,GAAaQ,MAAM,CAACK,GAAP,CAAWb,CAHzB;AAIA,KATD;AAUA,GAXD;AAYA;AAED,OAAO,SAASyB,oBAAT,CAA8B3C,KAA9B,EAAoC;AAC1C,QAAM4C,aAAa,GAAC,EAApB;AAEA,QAAMC,YAAY,GAAC7C,KAAK,CAAC8C,YAAN,CAAmB7C,KAAtC;AACA,QAAM8C,QAAQ,GAACF,YAAY,CAACE,QAA5B;AAEA,QAAMC,kBAAkB,GAACH,YAAY,CAACI,UAAtC;;AACAJ,EAAAA,YAAY,CAACI,UAAb,GAAwB,SAASC,cAAT,CAAwBrC,CAAxB,EAA0BK,CAA1B,EAA4B;AACnD0B,IAAAA,aAAa,CAACO,IAAd,CAAmB;AAACtC,MAAAA,CAAD;AAAGK,MAAAA;AAAH,KAAnB;AACA,WAAO8B,kBAAkB,CAACI,IAAnB,CAAwBP,YAAxB,EAAqChC,CAArC,EAAuCK,CAAvC,CAAP;AACA,GAHD;;AAKA,SAAO,SAASmC,aAAT,CAAuB9C,OAAvB,EAA+B;AACrCA,IAAAA,OAAO,CAAC+C,WAAR,GAAoB,MAApB;AACAV,IAAAA,aAAa,CAAC5B,OAAd,CAAsB,CAAC;AAACH,MAAAA,CAAD;AAAGK,MAAAA;AAAH,KAAD,KAAS;AAC9BX,MAAAA,OAAO,CAACgD,SAAR;AACAhD,MAAAA,OAAO,CAACiD,IAAR,CACC3C,CAAC,GAACkC,QAAF,GAAWrB,MAAM,CAACK,GAAP,CAAWlB,CADvB,EAECK,CAAC,GAAC6B,QAAF,GAAWrB,MAAM,CAACK,GAAP,CAAWb,CAFvB,EAGC6B,QAHD,EAGUA,QAHV,EAF8B,CAM9B;AACA;AACA,KARD;AAUAxC,IAAAA,OAAO,CAAC+C,WAAR,GAAoB,KAApB;AACAtD,IAAAA,KAAK,CAACmC,QAAN,CAAenB,OAAf,CAAuByB,MAAM,IAAE;AAC9BlC,MAAAA,OAAO,CAACgD,SAAR;AACAhD,MAAAA,OAAO,CAACiD,IAAR,CACCf,MAAM,CAACV,GAAP,CAAWlB,CAAX,GAAaa,MAAM,CAACK,GAAP,CAAWlB,CADzB,EAEC4B,MAAM,CAACV,GAAP,CAAWb,CAAX,GAAaQ,MAAM,CAACK,GAAP,CAAWb,CAFzB,EAGCuB,MAAM,CAACZ,IAAP,CAAYhB,CAHb,EAIC4B,MAAM,CAACZ,IAAP,CAAYX,CAJb,EAF8B,CAO9B;AACA,KARD;AAUA0B,IAAAA,aAAa,CAACa,MAAd,GAAqB,CAArB;AACA,GAxBD;AAyBA;AAED,OAAO,SAASC,iBAAT,CAA2BC,YAA3B,EAAwC;AAC9C,SAAO,SAASC,cAAT,CAAwBrD,OAAxB,EAAgCsD,UAAhC,EAA2C;AACjDtD,IAAAA,OAAO,CAAC+C,WAAR,GAAoB,QAApB;AACA/C,IAAAA,OAAO,CAACgD,SAAR;AACChD,IAAAA,OAAO,CAACiD,IAAR,CACCG,YAAY,CAAC5B,GAAb,CAAiBlB,CAAjB,GAAmBgD,UAAU,CAAC9B,GAAX,CAAelB,CADnC,EAEC8C,YAAY,CAAC5B,GAAb,CAAiBb,CAAjB,GAAmB2C,UAAU,CAAC9B,GAAX,CAAeb,CAFnC,EAGCyC,YAAY,CAAC9B,IAAb,CAAkBhB,CAHnB,EAIC8C,YAAY,CAAC9B,IAAb,CAAkBX,CAJnB;AAKAX,IAAAA,OAAO,CAACuD,MAAR;AACD,GATD;AAUA","sourcesContent":["import TileResolver from './TileResolver.js';\r\n\r\nexport function createBackgroundLayer (level,tiles, sprites){\r\n\tconst resolver = new TileResolver(tiles);\r\n\r\n\t//const buffer=document.createElement('canvas');\r\n \tbuffer.width=550;\r\n \tbuffer.height=640;\r\n \tconst context=buffer.getContext('2d');\r\n\r\n \tfunction redraw(startIndex,endIndex){\r\n \t\tcontext.clearRect(0,0,buffer.width,buffer.height);\r\n \t\tfor (let x=startIndex;x<=endIndex;++x){\r\n \t\t\tconst col = tiles.grid[x];\r\n \t\t\tif (col){\r\n \t\t\t\tcol.forEach((tile,y)=>{\r\n \t\t\t\t\tif (sprites.animation.has(tile.name)){\r\n \t\t\t\t\t\tsprites.drawAnim(tile.name,context,x-startIndex,y,level.totalTime);\r\n \t\t\t\t\t} else {\r\n \t\t\t\t\t\tsprites.drawtile(tile.name,context,x-startIndex,y);\r\n \t\t\t\t\t}\r\n \t\t\t\t});\r\n \t\t\t}\r\n \t\t}\r\n \t}\r\n\r\n \treturn function drawBackgroundLayer(context,camera){\r\n \t\tconst drawWidth=resolver.toIndex(camera.size.x);\r\n \t\tconst drawFrom=resolver.toIndex(camera.pos.x);\r\n \t\tconst drawTo=drawFrom+drawWidth;\r\n \t\tredraw(drawFrom,drawTo);  //+screenwidth here\r\n \t\tcontext.drawImage(buffer,\r\n \t\t\t-camera.pos.x%16,\r\n \t\t\t-camera.pos.y);\r\n \t};\r\n}\r\n\r\nexport function createSpriteLayer(entities, width=64,height=64){\r\n\tconst spriteBuffer=document.createElement('canvas');\r\n\tspriteBuffer.width=width;\r\n\tspriteBuffer.height=height;\r\n\tconst spriteBufferContext=spriteBuffer.getContext('2d');\r\n\r\n\treturn function drawSpriteLayer(context){\r\n\t\tentities.forEach(entity=>{\r\n\t\t\tspriteBufferContext.clearRect(0,0,width,height);\r\n\r\n\t\t\tentity.draw(spriteBufferContext);\r\n\r\n\t\t\tcontext.drawImage(\r\n\t\t\t\tspriteBuffer,\r\n\t\t\t\tentity.pos.x-camera.pos.x,\r\n\t\t\t\tentity.pos.y-camera.pos.y);\r\n\t\t});\r\n\t};\r\n}\r\n\r\nexport function createCollisionLayer(level){\r\n\tconst resolvedTiles=[];\r\n\r\n\tconst tileResolver=level.tileCollider.tiles;\r\n\tconst tileSize=tileResolver.tileSize;\r\n\r\n\tconst getByIndexOriginal=tileResolver.getByIndex;\r\n\ttileResolver.getByIndex=function getByIndexFake(x,y){\r\n\t\tresolvedTiles.push({x,y});\r\n\t\treturn getByIndexOriginal.call(tileResolver,x,y);\r\n\t}\r\n\r\n\treturn function drawCollision(context){\r\n\t\tcontext.strokeStyle='blue';\r\n\t\tresolvedTiles.forEach(({x,y})=>{\r\n\t\t\tcontext.beginPath();\r\n\t\t\tcontext.rect(\r\n\t\t\t\tx*tileSize-camera.pos.x,\r\n\t\t\t\ty*tileSize-camera.pos.y,\r\n\t\t\t\ttileSize,tileSize);\r\n\t\t\t//context.stroke();\r\n\t\t\t//console.log('Would draw',x,y);\r\n\t\t});\r\n\r\n\t\tcontext.strokeStyle='red';\r\n\t\tlevel.entities.forEach(entity=>{\r\n\t\t\tcontext.beginPath();\r\n\t\t\tcontext.rect(\r\n\t\t\t\tentity.pos.x-camera.pos.x,\r\n\t\t\t\tentity.pos.y-camera.pos.y,\r\n\t\t\t\tentity.size.x,\r\n\t\t\t\tentity.size.y);\r\n\t\t\t//context.stroke();\r\n\t\t})\r\n\r\n\t\tresolvedTiles.length=0;\r\n\t};\r\n}\r\n\r\nexport function createCameraLayer(cameraToDraw){\r\n\treturn function drawCameraRect(context,fromCamera){\r\n\t\tcontext.strokeStyle='purple';\r\n\t\tcontext.beginPath();\r\n\t\t\tcontext.rect(\r\n\t\t\t\tcameraToDraw.pos.x-fromCamera.pos.x,\r\n\t\t\t\tcameraToDraw.pos.y-fromCamera.pos.y,\r\n\t\t\t\tcameraToDraw.size.x,\r\n\t\t\t\tcameraToDraw.size.y);\r\n\t\t\tcontext.stroke();\r\n\t};\r\n}"]},"metadata":{},"sourceType":"module"}