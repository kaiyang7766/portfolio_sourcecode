{"ast":null,"code":"import TileResolver from './TileResolver.js';\nexport function createBackgroundLayer(level, tiles, sprites) {\n  const resolver = new TileResolver(tiles);\n  const buffer = document.createElement('canvas');\n  buffer.width = 550;\n  buffer.height = 640;\n  const context = buffer.getContext('2d');\n\n  function redraw(startIndex, endIndex) {\n    context.clearRect(0, 0, buffer.width, buffer.height);\n\n    for (let x = startIndex; x <= endIndex; ++x) {\n      const col = tiles.grid[x];\n\n      if (col) {\n        col.forEach((tile, y) => {\n          if (sprites.animation.has(tile.name)) {\n            sprites.drawAnim(tile.name, context, x - startIndex, y, level.totalTime);\n          } else {\n            sprites.drawtile(tile.name, context, x - startIndex, y);\n          }\n        });\n      }\n    }\n  }\n\n  return function drawBackgroundLayer(context, camera) {\n    const drawWidth = resolver.toIndex(camera.size.x);\n    const drawFrom = resolver.toIndex(camera.pos.x);\n    const drawTo = drawFrom + drawWidth;\n    redraw(drawFrom, drawTo); //+screenwidth here\n\n    context.drawImage(buffer, -camera.pos.x % 16, -camera.pos.y);\n  };\n} // export function createSpriteLayer(entities, width=64,height=64){\n// \tconst spriteBuffer=document.createElement('canvas');\n// \tspriteBuffer.width=width;\n// \tspriteBuffer.height=height;\n// \tconst spriteBufferContext=spriteBuffer.getContext('2d');\n// \treturn function drawSpriteLayer(context){\n// \t\tentities.forEach(entity=>{\n// \t\t\tspriteBufferContext.clearRect(0,0,width,height);\n// \t\t\tentity.draw(spriteBufferContext);\n// \t\t\tcontext.drawImage(\n// \t\t\t\tspriteBuffer,\n// \t\t\t\tentity.pos.x-camera.pos.x,  //here\n// \t\t\t\tentity.pos.y-camera.pos.y); //here\n// \t\t});\n// \t};\n// }\n// export function createCollisionLayer(level){\n// \tconst resolvedTiles=[];\n// \tconst tileResolver=level.tileCollider.tiles;\n// \tconst tileSize=tileResolver.tileSize;\n// \tconst getByIndexOriginal=tileResolver.getByIndex;\n// \ttileResolver.getByIndex=function getByIndexFake(x,y){\n// \t\tresolvedTiles.push({x,y});\n// \t\treturn getByIndexOriginal.call(tileResolver,x,y);\n// \t}\n// \treturn function drawCollision(context){\n// \t\tcontext.strokeStyle='blue';\n// \t\tresolvedTiles.forEach(({x,y})=>{\n// \t\t\tcontext.beginPath();\n// \t\t\tcontext.rect(\n// \t\t\t\tx*tileSize-camera.pos.x, //here\n// \t\t\t\ty*tileSize-camera.pos.y, //here\n// \t\t\t\ttileSize,tileSize);\n// \t\t\t//context.stroke();\n// \t\t\t//console.log('Would draw',x,y);\n// \t\t});\n// \t\tcontext.strokeStyle='red';\n// \t\tlevel.entities.forEach(entity=>{\n// \t\t\tcontext.beginPath();\n// \t\t\tcontext.rect(\n// \t\t\t\tentity.pos.x-camera.pos.x, //here\n// \t\t\t\tentity.pos.y-camera.pos.y, //here\n// \t\t\t\tentity.size.x,\n// \t\t\t\tentity.size.y);\n// \t\t\t//context.stroke();\n// \t\t})\n// \t\tresolvedTiles.length=0;\n// \t};\n// }\n\nexport function createCameraLayer(cameraToDraw) {\n  return function drawCameraRect(context, fromCamera) {\n    context.strokeStyle = 'purple';\n    context.beginPath();\n    context.rect(cameraToDraw.pos.x - fromCamera.pos.x, cameraToDraw.pos.y - fromCamera.pos.y, cameraToDraw.size.x, cameraToDraw.size.y);\n    context.stroke();\n  };\n}","map":{"version":3,"sources":["C:/Users/Ang Kai Yang/Desktop/portfolio/src/main/layers.js"],"names":["TileResolver","createBackgroundLayer","level","tiles","sprites","resolver","buffer","document","createElement","width","height","context","getContext","redraw","startIndex","endIndex","clearRect","x","col","grid","forEach","tile","y","animation","has","name","drawAnim","totalTime","drawtile","drawBackgroundLayer","camera","drawWidth","toIndex","size","drawFrom","pos","drawTo","drawImage","createCameraLayer","cameraToDraw","drawCameraRect","fromCamera","strokeStyle","beginPath","rect","stroke"],"mappings":"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","sourcesContent":["import TileResolver from './TileResolver.js';\r\n\r\nexport function createBackgroundLayer (level,tiles, sprites){\r\n\tconst resolver = new TileResolver(tiles);\r\n\r\n\tconst buffer=document.createElement('canvas');\r\n \tbuffer.width=550;\r\n \tbuffer.height=640;\r\n \tconst context=buffer.getContext('2d');\r\n\r\n \tfunction redraw(startIndex,endIndex){\r\n \t\tcontext.clearRect(0,0,buffer.width,buffer.height);\r\n \t\tfor (let x=startIndex;x<=endIndex;++x){\r\n \t\t\tconst col = tiles.grid[x];\r\n \t\t\tif (col){\r\n \t\t\t\tcol.forEach((tile,y)=>{\r\n \t\t\t\t\tif (sprites.animation.has(tile.name)){\r\n \t\t\t\t\t\tsprites.drawAnim(tile.name,context,x-startIndex,y,level.totalTime);\r\n \t\t\t\t\t} else {\r\n \t\t\t\t\t\tsprites.drawtile(tile.name,context,x-startIndex,y);\r\n \t\t\t\t\t}\r\n \t\t\t\t});\r\n \t\t\t}\r\n \t\t}\r\n \t}\r\n\r\n \treturn function drawBackgroundLayer(context,camera){\r\n \t\tconst drawWidth=resolver.toIndex(camera.size.x);\r\n \t\tconst drawFrom=resolver.toIndex(camera.pos.x);\r\n \t\tconst drawTo=drawFrom+drawWidth;\r\n \t\tredraw(drawFrom,drawTo);  //+screenwidth here\r\n \t\tcontext.drawImage(buffer,\r\n \t\t\t-camera.pos.x%16,\r\n \t\t\t-camera.pos.y);\r\n \t};\r\n}\r\n\r\n// export function createSpriteLayer(entities, width=64,height=64){\r\n// \tconst spriteBuffer=document.createElement('canvas');\r\n// \tspriteBuffer.width=width;\r\n// \tspriteBuffer.height=height;\r\n// \tconst spriteBufferContext=spriteBuffer.getContext('2d');\r\n\r\n// \treturn function drawSpriteLayer(context){\r\n// \t\tentities.forEach(entity=>{\r\n// \t\t\tspriteBufferContext.clearRect(0,0,width,height);\r\n\r\n// \t\t\tentity.draw(spriteBufferContext);\r\n\r\n// \t\t\tcontext.drawImage(\r\n// \t\t\t\tspriteBuffer,\r\n// \t\t\t\tentity.pos.x-camera.pos.x,  //here\r\n// \t\t\t\tentity.pos.y-camera.pos.y); //here\r\n// \t\t});\r\n// \t};\r\n// }\r\n\r\n// export function createCollisionLayer(level){\r\n// \tconst resolvedTiles=[];\r\n\r\n// \tconst tileResolver=level.tileCollider.tiles;\r\n// \tconst tileSize=tileResolver.tileSize;\r\n\r\n// \tconst getByIndexOriginal=tileResolver.getByIndex;\r\n// \ttileResolver.getByIndex=function getByIndexFake(x,y){\r\n// \t\tresolvedTiles.push({x,y});\r\n// \t\treturn getByIndexOriginal.call(tileResolver,x,y);\r\n// \t}\r\n\r\n// \treturn function drawCollision(context){\r\n// \t\tcontext.strokeStyle='blue';\r\n// \t\tresolvedTiles.forEach(({x,y})=>{\r\n// \t\t\tcontext.beginPath();\r\n// \t\t\tcontext.rect(\r\n// \t\t\t\tx*tileSize-camera.pos.x, //here\r\n// \t\t\t\ty*tileSize-camera.pos.y, //here\r\n// \t\t\t\ttileSize,tileSize);\r\n// \t\t\t//context.stroke();\r\n// \t\t\t//console.log('Would draw',x,y);\r\n// \t\t});\r\n\r\n// \t\tcontext.strokeStyle='red';\r\n// \t\tlevel.entities.forEach(entity=>{\r\n// \t\t\tcontext.beginPath();\r\n// \t\t\tcontext.rect(\r\n// \t\t\t\tentity.pos.x-camera.pos.x, //here\r\n// \t\t\t\tentity.pos.y-camera.pos.y, //here\r\n// \t\t\t\tentity.size.x,\r\n// \t\t\t\tentity.size.y);\r\n// \t\t\t//context.stroke();\r\n// \t\t})\r\n\r\n// \t\tresolvedTiles.length=0;\r\n// \t};\r\n// }\r\n\r\nexport function createCameraLayer(cameraToDraw){\r\n\treturn function drawCameraRect(context,fromCamera){\r\n\t\tcontext.strokeStyle='purple';\r\n\t\tcontext.beginPath();\r\n\t\t\tcontext.rect(\r\n\t\t\t\tcameraToDraw.pos.x-fromCamera.pos.x,\r\n\t\t\t\tcameraToDraw.pos.y-fromCamera.pos.y,\r\n\t\t\t\tcameraToDraw.size.x,\r\n\t\t\t\tcameraToDraw.size.y);\r\n\t\t\tcontext.stroke();\r\n\t};\r\n}"]},"metadata":{},"sourceType":"module"}